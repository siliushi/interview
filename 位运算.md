&
|
^
~
<< 零填充向左位移，从右侧推入0向左侧位移
>> 有符号向右位移，拷贝最左侧元素，从左侧推入向右位移，使最右侧脱落,把二进制位右移指定的位数，左边根据符号位补0或1（有符号右移）。
>>> 零填充向右位移，从左侧推入0向右位移,把二进制位右移指定的位数，左边总是补0（无符号右移）。

所有操作用二进制码，算结果时负数转补码

32位有符号整数来表示数字

** 任何操作（&、|、^、~、<<、>>、>>>）之后，得到的是负数就要算补码，对应的就是十进制数据 **

小数取整~~ 或者 ｜0，只适用于 32 位数字

0是正数，1是负数

# ～5是-6
1. 5 的二进制表示：00000000 00000000 00000000 00000101
2. 取反操作：11111111 11111111 11111111 11111010
3. 解释取反后的结果: 上面的二进制数是一个有符号整数的表示。因为最高位是 1，表示这是一个负数。在计算机中，有符号整数通常使用二进制补码来表示负数。
4. 计算补码:
二进制补码是通过对该负数的绝对值的二进制表示取反加 1 得到的
现在我们已经得到了 11111111 11111111 11111111 11111010，为了计算其对应的十进制值，我们需要取反（变回原来的正数部分）再加 1：
00000000 00000000 00000000 00000110
5. 符号应用
由于原始的二进制数的最高位是 1，表示这是一个负数，因此最终结果是 -6。


# -5>>>1 会返回 2147483645
1. 负数，计算机采用补码来表示，绝对值的二进制取反+1
5:00000000 00000000 00000000 00000101
取反+1：11111111 11111111 11111111 11111011
向右无符号零填充：011111111 11111111 11111111 1111101
求对应十进制值
parseInt(011111111 11111111 11111111 1111101, 2).toString(10)

# -5>>1
// -5>>1
// 负数以补码的形式存在，绝对值取反+1
// 绝对值：00000000000000000000000000000101
// 取反+1：11111111111111111111111111111011
// 有符号向右移动一位，对应二进制
// 11111111111111111111111111111101
parseInt('11111111111111111111111111111101', 2) | 0 -3
// 为了计算十进制值需要算补码
// -10000000000000000000000000000011   -3



JavaScript 中的位操作符（如 |, &, ^, ~ 等）会自动将操作数转换为 32 位有符号整数。
这些位操作符会按照 32 位有符号整数的形式进行处理，因此结果也会被解释为 32 位有符号整数。

二进制转十进制
有符号(二进制数据，算补码)：parseInt('11111111111111111111111111111010',2) | 0
无符号：parseInt('11111111111111111111111111111010',2).toString(10)


https://juejin.cn/post/7322313142922559498
IEEE754：https://juejin.cn/post/6996945105273765924
0.1+0.2
十进制转二进制导致精度丢失
十进制整数转二进制：除二取余，倒序排列
十进制小数转成二进制，一般采用"乘2取整，顺序排列"方法，但是不是所有小数都能转为二进制，比如0.1，人们想出了一种使用近似值表示小数IEEE754
IEEE754 double类型8个字节，64位,符号为+尾数+阶码
64位IEE754
1位符号为，11位尾数位，52位阶码
2^-52  Number.EPSILON
32位IEEE754
1 8 23


# 既有整数又有小数
整数部分，除2倒取余
小数部分，乘2取整
二进制：整数部分.小数部分


JavaScript有效整数的范围是53位