<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 动态作用域，与调用位置有关
        function foo() { 
            console.log( a ); // 3（不是 2 ！） 
        }
        function bar() {
            var a = 3;
            foo();
        }
        var a = 2;
        bar();


        // this绑定规则
        // 1、默认绑定,严格模式无法使用默认绑定
        var a = 2;
        function foo() {
            console.log(123123, this.a)
        }
        foo()
        // 严格模式下 undefined，与 foo() 的调用位置无关，与定义有关
        var a = 2;
        function foo() {
            // 'use strict';
            console.log(123123, this.a)
        }
        (function () {
            'use strict'
            foo() // 2
        })()
        // 2、隐式绑定，链式调用最后一层会影响调用位置
        function foo() { 
            console.log(this.a); 
        }
        var obj2 = { a: 42, foo: foo };
        var obj1 = { a: 2, obj2: obj2 };
        obj1.obj2.foo(); // 42


        function foo() {
            console.log(this.a);
        }
        function doFoo(fn) { // fn 其实引用的是 foo
            fn(); // <-- 调用位置！ 
        }
        var obj = { a: 2, foo: foo };
        var a = "oops, global"; // a 是全局对象的属性
        doFoo(obj.foo); // "oops, global"

        // ====只要是自己主动执行的，都指向全局window

        // 3、显示绑定，call、apply
        // 如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者 new Number(..)）。这通常被称为“装箱”。

        // 3.1硬绑定
        function foo(something) {
            console.log(this.a, something);
            return this.a + something;
        }
        var obj = { a: 2 };
        var bar = function () {
            return foo.apply(obj, arguments);
        };
        var b = bar(3); // 2 3
        console.log(b); // 5


        // bind
        // bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。
        function foo(something) {
            console.log(this.a, something);
            return this.a + something;
        }
        // 简单的辅助绑定函数
        function bind(fn, obj) {
            return function () {
                return fn.apply(obj, arguments);
            };
        }
        var obj = { a: 2 };
        var bar = bind(foo, obj);
        var b = bar(3); // 2 3 console.log( b ); // 5

        // 3.2 API调用的“上下文”
        function foo(el) { console.log(el, this.id); }
        var obj = { id: "awesome" };
        // 调用 foo(..) 时把 this 绑定到 obj 
        [1, 2, 3].forEach(foo, obj);
        // 1 awesome 2 awesome 3 awesome


        // 4、new绑定
        // 实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。
        // new 来调用函数
        // 1. 创建（或者说构造）一个全新的对象。 
        // 2. 这个新对象会被执行 [[ 原型 ]] 连接。 
        // 3. 这个新对象会绑定到函数调用的 this。 
        // 4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。

        // P93页

        // 优先级
        // new > 显示 > 隐示 > 默认

        // 判断this
        // 1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 
        //     var bar = new foo() 
        // 2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 
        //     var bar = foo.call(obj2) 
        // 3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 
        //     var bar = obj1.foo() 
        // 4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 
        //     var bar = foo()

        // 被忽略的this
        // 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则：
        function foo() {
            console.log(this.a);
        }
        var a = 2;
        foo.call(null); // 2

        // 间接引用
        function foo() { console.log(this.a); }
        var a = 2;
        var o = { a: 3, foo: foo };
        var p = { a: 4 }; o.foo(); // 3 
        (p.foo = o.foo)(); // 2
        // 赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是foo()而不是p.foo()或者o.foo()。根据我们之前说过的，这里会应用默认绑定。


        let aa = {aa: 'aa'};
        [1,2,3].forEach(function(item) {
            console.log(this.aa , item)
        },aa)
    </script>
</body>

</html>