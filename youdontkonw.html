<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 作用域：根据名称查找变量的一套规则
        // 大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。JavaScript引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳。
        // 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。
        // 变量RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图 找到变量的容器本身，从而可以对其赋值。
        // 宽松模式下，如果引擎查找不到变量，作用域会创建一个变量，严格模式下不行
        function foo111(a) {
            console.log(a + b); // NaN
            b = a;
        }
        foo111(2);

        // 词法作用域：由书写代码时函数声明的位置来决定的
        // 作用域查找会在找到第一个匹配的标识符时停止。
        // 词法作用域查找只会查找一级标识符，如果代码中引用了foo.bar.baz，词法作用域查找只会试图查找foo标识符，找到这个变量后，对象属性访问规则会分别接 管对 bar 和 baz 属性的访问。

        // 在运行时修改词法作用域，
        // eval：相当于将字符串在当前环境执行，严格模式下会生成自己的作用域
        function foo(str, a) {
            eval( str ); // 欺骗！
            console.log( a, b ); 
        }
        var b = 2;
        foo( "var b = 3;", 1 ); // 1, 3
        // setTimeout(..) 和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的 函数代码。
        // new Function(..) 最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。
        // with
        var obj = { a: 1, b: 2, c: 3 };
        // 单调乏味的重复 "obj"
        obj.a = 2;
        obj.b = 3;
        obj.c = 4; 
        // 简单的快捷方式
        with (obj) {
            a = 3;
            b = 4;
            c = 5;
        }
        // 如果with给obj赋值一个没有的属性，非严格模式下会创建一个全局属性并赋值
        // 严格模式下，with和eval都被禁用，因为在词法分析阶段，无法确定代码会对作用域进行如何修改
        // JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的 词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到 标识符。

        // 匿名函数
        // 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
        // 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用

        // IIFE
        // (function() {})()
        // (function() {}())
        // 还有一种变化的用途是倒置代码的运行顺序
        (function(def) {def()})(function() {console.log(123)})

        // 块作用域
        // with 
        // try/catch 其中声明的变量仅在 catch 内部有效

        // 提升：变量和函数，函数会首先被提升，然后才是变量，在后面的函数声明还是可以覆盖前面的
        // 声明变量并赋值：声明和执行两步，先声明变量，赋值留在原地等待执行
        footest()
        function footest() {
            console.log(987)
        }
        foo(); // 查找不到方法，因为foo包在条件语句里不能进行函数提升
        var a = true;
        if (a) {
        function foo() { console.log("a"); } }
        else {
        function foo() { console.log("b"); } }

        
        // 闭包：在不污染外部作用域的情况下，访问词法作用域以外的变量

        // 模块模式
        // 1、必须有外部的封闭函数，该函数必须至少被调用一次
        // 2、封闭函数必须返回至少一个内部函数


        // 动态作用域，不关心函数是如何声明以及在何处声明,只关心它们从何处调
        // 'use strict';
        // 重复声明函数或变量，后面的覆盖前面的
        var a = 1;
        var a = 2;
        console.log(a)
        // 重复声明函数
        function reclar() {
            console.log(1111111111)
        }
        function reclar() {
            console.log(2)
        }
        reclar();
        function foo() {
            console.log(a); // 3（不是 2 ！） 
        }
        function bar() {
            var a = 3;
            foo();
        }
        var a = 2;
        bar();


        // 箭头函数继承了上层函数的this绑定


        // this被自动定义在所有函数的作用域中
        // this绑定规则
        // 1、默认绑定,严格模式无法使用默认绑定
        var a = 2;
        function foo() {
            console.log(123123, this.a)
        }
        foo()
        // 严格模式下 undefined，与 foo() 的调用位置无关，与定义有关
        var a = 2;
        function foo() {
            // 'use strict';
            console.log(123123, this.a)
        }
        (function () {
            // 'use strict'
            foo() // 2
        })()
        // 2、隐式绑定，链式调用最后一层会影响调用位置
        function foo() {
            console.log(this.a);
        }
        var obj2 = { a: 42, foo: foo };
        var obj1 = { a: 2, obj2: obj2 };
        obj1.obj2.foo(); // 42


        function foo() {
            console.log(this.a);
        }
        function doFoo(fn) { // fn 其实引用的是 foo
            fn(); // <-- 调用位置！ 
        }
        var obj = { a: 2, foo: foo };
        var a = "oops, global"; // a 是全局对象的属性
        doFoo(obj.foo); // "oops, global"

        // ====只要是自己主动执行的，都指向全局window

        // 3、显示绑定，call、apply
        // 如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者 new Number(..)）。这通常被称为“装箱”。

        // 3.1硬绑定
        function foo(something) {
            console.log(this.a, something);
            return this.a + something;
        }
        var obj = { a: 2 };
        var bar = function () {
            return foo.apply(obj, arguments);
        };
        var b = bar(3); // 2 3
        console.log(b); // 5


        // bind
        // bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。
        function foo(something) {
            console.log(this.a, something);
            return this.a + something;
        }
        // 简单的辅助绑定函数
        function bind(fn, obj) {
            return function () {
                return fn.apply(obj, arguments);
            };
        }
        var obj = { a: 2 };
        var bar = bind(foo, obj);
        var b = bar(3); // 2 3 console.log( b ); // 5

        // 3.2 API调用的“上下文”
        function foo(el) { console.log(el, this.id); }
        var obj = { id: "awesome" };
        // 调用 foo(..) 时把 this 绑定到 obj 
        [1, 2, 3].forEach(foo, obj);
        // 1 awesome 2 awesome 3 awesome


        // 4、new绑定
        // 实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。
        // new 来调用函数
        // 1. 创建（或者说构造）一个全新的对象。 
        // 2. 这个新对象会被执行 [[ 原型 ]] 连接。 
        // 3. 这个新对象会绑定到函数调用的 this。 
        // 4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。

        // P93页

        // 优先级
        // new > 显示 > 隐示 > 默认

        // 判断this
        // 1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。 
        //     var bar = new foo() 
        // 2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是 指定的对象。 
        //     var bar = foo.call(obj2) 
        // 3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上 下文对象。 
        //     var bar = obj1.foo() 
        // 4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。 
        //     var bar = foo()

        // 被忽略的this
        // 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值 在调用时会被忽略，实际应用的是默认绑定规则：
        // 可以传入一个空对象来代替null或者undefined，比如var ø = Object.create(null)
        function foo() {
            console.log(this.a);
        }
        var a = 2;
        foo.call(null); // 2

        // 间接引用
        function foo() { console.log(this.a); }
        var a = 2;
        var o = { a: 3, foo: foo };
        var p = { a: 4 }; o.foo(); // 3
        (p.foo = o.foo)(); // 2
        // 赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是foo()而不是p.foo()或者o.foo()。根据我们之前说过的，这里会应用默认绑定。


        // 软绑定
        // 给默认绑定指定一个全局对象和 undefined 以外的值，当执行绑定时判断this是否是window，如果是就绑定到obj

        // 如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。 
        // 1. 由 new 调用？绑定到新创建的对象。 
        // 2. 由 call 或者 apply（或者 bind）调用？绑定到指定的对象。 
        // 3. 由上下文对象调用？绑定到那个上下文对象。
        // 4. 默认：在严格模式下绑定到 undefined，否则绑定到全局对象。



        // 内置对象
        // • String • Number • Boolean • Object • Function • Array • Date • RegExp • Error
        var strPrimitive = "I am a string";
        typeof strPrimitive; // "string" 
        strPrimitive instanceof String; // false
        var strObject = new String( "I am a string" );
        typeof strObject; // "object" 
        strObject instanceof String; // true 
        // 检查 sub-type 对象 
        Object.prototype.toString.call( strObject ); // [object String]

        // 对象
        // .被称为属性访问，属性名满足标识符的命名规范
        // []被称为键访问，接受任意 UTF-8/Unicode 字符串作为属性名

        // 浅赋值Object.assign，由于 Object.assign(..) 就是使用 = 操作符来赋值，所以源对象属性的一些特性（比如 writable）不会被复制到目标对象。

        // 不变性：对象引用的其他对象是不受影响的
        // 属性描述符：Object.getOwnPropertyDescriptor( myObject, "a" );
        // writable（可写）、 enumerable（可枚举）和 configurable（可配置）
        // configurable为false的话writeable一定为false，不可修改、 重定义或者删除

        // 禁止扩展
        // 禁 止 一 个 对 象 添 加 新 属 性 并 且 保 留 已 有 属 性：Object.preventExtensions(obj)

        // 密封：Object.seal()密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以 修改属性的值）
        // 在一个现有对象上调用Object.preventExtensions(obj)并把所有现有属性标记为configurable:false。

        // 冻结:Object.freeze()
        // 会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们 的值。


        // [[Get]] 操作： Object.a就执行了Get操作，首先在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。否则遍历可能存在的 [[Prototype]] 链， 也就是原型链
        var myObject = { 
            a: undefined
        };
        myObject.a; // undefined 
        myObject.b; // undefined
        // [[Put]]操作：
        // 如果已经存在这个属性
        // 1. 属性是否是访问描述符（参见 3.3.9 节）？如果是并且存在 setter 就调用 setter。 
        // 2. 属性的数据描述符中 writable 是否是 false ？如果是，在非严格模式下静默失败，在 严格模式下抛出 TypeError 异常。 
        // 3. 如果都不是，将该值设置为属性的值。
        // 如果对象中不存在这个属性
        // 1. 如果在[[Prototype]]链上层存在名为foo的普通数据访问属性并且没有被标记为只读（writable:false），那就会直接在myObject中添加一个名为foo的新属性，它是屏蔽属性。
        // 2. 如果在[[Prototype]]链上层存在foo，但是它被标记为只读（writable:false），那么无法修改已有属性或者在myObject上创建屏蔽属性。如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。
        // 3. 如果在[[Prototype]]链上层存在foo并且它是一个setter，那就一定会调用这个setter。foo不会被添加到（或者说屏蔽于）myObject，也不会重新定义foo这个setter。

        // Getter和Setter“访问描述 符”
        // 使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。
        // 当属性定义Getter和Setter，会忽略它们的 value 和 writable 特性，取而代之的是关心 set 和 get（还有 configurable 和 enumerable）特性。
        var myObject = { 
            _a_: 2,
            // 给 a 定义一个 getter 
            get a() { return this._a_; },
            // 给 a 定义一个 setter 
            set a(val) {
                this._a_ = val * 2;
            }
        };
        Object.defineProperty( 
            myObject, // 目标对象
            "b", // 属性名 
            {
                // 描述符 
                // 给 b 设置一个 getter 
                get: function(){ return this.a * 2 }, 
                // 确保 b 会出现在对象的属性列表中 
                enumerable: true 
            }
        );
        console.log('myObject.a',myObject.a); // 2 
        console.log('myObject.b',myObject.b); // 4

        // 判断属性是否在对象里
        ("a" in myObject) // in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中
        myObject.hasOwnProperty( "a" ); // 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链

        // 所有的普通对象都可以通过对于 Object.prototype的委托来访问hasOwnProperty(..)，但是有的对象可能没有连接到 Object.prototype（通过 Object. create(null)来创建）。
        // 在这种情况下，形如 myObejct.hasOwnProperty(..)就会失败。 这时可以使用一种更加强硬的方法来进行判断：Object.prototype.hasOwnProperty. call(myObject,"a")，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定（参见第 2 章）到 myObject 上。
        
        // 枚举 enumerable
        // enumerable为false不影响in或者hasOwnProperty，  影响for in
        // myObject.propertyIsEnumerable( "a" );检查给定的属性名是否直接存在于对象中（而不是在原型链 上）并且满足 enumerable:true。
        // Object.keys( myObject ); // ["a"]
        // Object.getOwnPropertyNames( myObject ); // ["a", "b"]

        // 对象没有内置迭代器@@iterator，为了避免影响未来的对象 类型。
        var myObject = { a: 2, b: 3 };
        Object.defineProperty( myObject, Symbol.iterator, {
            enumerable: false,
            writable: false,
            configurable: true,
            value: function() {
                var o = this;
                var idx = 0;
                var ks = Object.keys( o );
                return { 
                    next: function() {
                        return { value: o[ks[idx++]], done: (idx > ks.length) }; 
                    } 
                }; 
            } 
        }); 
        // 手动遍历 myObject 
        var it = myObject[Symbol.iterator](); 
        it.next(); // { value:2, done:false } 
        it.next(); // { value:3, done:false } 
        it.next(); // { value:undefined, done:true }
        // 用 for..of 遍历 myObject
        for (var v of myObject) { console.log( v ); }// 2 // 3

        // 数组
        // every(..) 会一直运行直到回调函数返回 false（或者“假”值），some(..) 会一直运行直到回调函数返回 true（或者 “真”值）
        // 内置迭代器@@iterator
        var myArray = [ 1, 2, 3 ];
        var it = myArray[Symbol.iterator](); 
        it.next(); // { value:1, done:false } 
        it.next(); // { value:2, done:false } 
        it.next(); // { value:3, done:false } 
        it.next(); // { done:true }



        // 混合对象类
        // 设计模式：实例化（instantiation）、继承（inheritance）和 （相对）多态（polymorphism）。

        // 子类得到的只是父类的一份副本。类的继承其实就是 复制

        // 混入Mixin
        // 显示/隐士
        
        // 原型
        var anotherObject = { a:2 };
        var myObject = Object.create( anotherObject ); // 创建一个对象并把这个对象的 [[Prototype]] 关联到指定的对象。
        myObject.a;


        let aa = { aa: 'aa' };
        [1, 2, 3].forEach(function (item) {
            console.log(this.aa, item)
        }, aa)


        // 赋值，只要是对象（属性是对象也算），修改属性会影响原对象
        let origin = {
            a: {
                b: 1
            }
        }
        // let copy = { a: {} }
        // copy.a = origin.a
        // copy.a.b = 0;
        // console.log(origin)

    </script>
</body>

</html>