# 声明式UI库

+ JSX
+ props组件对外接口，state组件内部状态
+ 组件生命周期


react源码   React源码深度解析：从理念到架构，从架构到实现，从实现到具体代码。
https://react.iamkasong.com/
https://pomb.us/build-your-own-react/



setTimeout 延迟加载 （使用不当可能适得其反）
web worker 多线程 （不能操作dom，主要计算密集型的任务）
requestIdleCallback 帧空闲时运行 （react18带🔥的，低优先级任务）
requestAnimationFrame 每帧都会运行 （主要做动画效果调优）

https://juejin.cn/post/7181356579709517861

schedule 调度 scheduler 小顶堆数据结构
render 协调 reconciler  fiber 深度优先遍历（dfs）
commit 渲染  render ReactDOM ReactArt

lane模型 优先级模型 了解二进制掩码

ClassComponent     面向对象
FunctionComponent  函数式（编译时优化，useMemo useCallback）

hooks 代数效应

event loop
message channel 宏任务 微任务


# 理念
快速响应
- CPU的瓶颈：当遇到大计算量的操作或者设备性能不足使页面掉帧，导致卡顿。
    - 时间切片：预留5ms给react
- IO的瓶颈：发送网络请求后，由于需要等待数据返回才能进一步操作导致不能快速响应。
    - suspense + useDeferredValue  同步的更新编程可中断的异步更新
主流浏览器刷新频率为 60Hz，即每（1000ms / 60Hz）16.6ms 浏览器刷新一次。
JS可以操作DOM，GUI渲染线程与JS线程是互斥的。所以JS脚本执行和浏览器布局、绘制不能同时执行。

## React15
React15 架构可以分为两层：

Reconciler（协调器）—— 负责找出变化的组件
Renderer（渲染器）—— 负责将变化的组件渲染到页面上



包含fiber、双缓存、JSX编译、diff算法等内容。
CPU卡顿，时间切片，预留yieldInterval = 5ms给js，
I/O卡顿，将同步的长任务转变为可中断的异步任务，增加loading，Suspense

React15只有同步任务
- Reconciler 协调器
    1、调用函数组件或是类组件的 render 方法，将JSX转化为虚拟DOM
    2、将虚拟DOM和上次更新时的虚拟DOM对比、通过对比找出需要改变的虚拟DOM
    3、通知Renderer将变化的虚拟DOM渲染到页面上
- Renderer 渲染器
    负责将虚拟DOM渲染到页面上。

问题：
mount组件时，会调用mountComponent方法，它会根据标签调用mountWrapper，而mountWrapper又会调用mountComponent方法，也就是进行了递归的过程。
同理，update 组件时会触发updateComponent方法，也会进行递归。
如果递归层级很深，那么执行时间超过16ms时，用户交互就会卡顿。
并且React15采用的递归方式不支持中断。

React16
增加Scheduler调度器，负责让高优先级的任务先进入Reconciler执行。
对于优先级调度，很多人最先会想到requestIdleCallback这个API，然而因为它不兼容safari，并且触发频率不稳定，因此React实现了自己的requestIdleCallbackpolyfill。
React16还实现了workLoopConcurrent，用可中断的异步任务来代替递归遍历的方式，通过shouldYield来判断是否需要中断。



不能在函数组件上直接使用ref，因为其没有实例



# 问题
父组件内部状态更新，子组件不应该更新
跨组件传值导致中间组件不必要的更新